// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.23.0
// source: users.sql

package dao

import (
	"context"
)

const addPrimaryEmailForUser = `-- name: AddPrimaryEmailForUser :exec
INSERT INTO emails (
  createdAt, updatedAt, user_id, address, isPrimary, verifiedAt
)
VALUES (CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, ?1, ?2, true, CURRENT_TIMESTAMP)
`

type AddPrimaryEmailForUserParams struct {
	UserID  int64
	Address string
}

func (q *Queries) AddPrimaryEmailForUser(ctx context.Context, arg AddPrimaryEmailForUserParams) error {
	_, err := q.db.ExecContext(ctx, addPrimaryEmailForUser, arg.UserID, arg.Address)
	return err
}

const addSecondaryEmailForUser = `-- name: AddSecondaryEmailForUser :exec
INSERT INTO emails (
  createdAt, updatedAt, user_id, address, isPrimary
)
VALUES (CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, ?1, ?2, false)
`

type AddSecondaryEmailForUserParams struct {
	UserID  int64
	Address string
}

func (q *Queries) AddSecondaryEmailForUser(ctx context.Context, arg AddSecondaryEmailForUserParams) error {
	_, err := q.db.ExecContext(ctx, addSecondaryEmailForUser, arg.UserID, arg.Address)
	return err
}

const associateSessionWithUser = `-- name: AssociateSessionWithUser :exec
INSERT INTO users_sessions (
  user_id, token, createdBy
) VALUES (
  ?1, ?2, ?3
)
`

type AssociateSessionWithUserParams struct {
	UserID    int64
	Token     string
	Createdby string
}

func (q *Queries) AssociateSessionWithUser(ctx context.Context, arg AssociateSessionWithUserParams) error {
	_, err := q.db.ExecContext(ctx, associateSessionWithUser, arg.UserID, arg.Token, arg.Createdby)
	return err
}

const createUserAndReturnId = `-- name: CreateUserAndReturnId :one
INSERT INTO users (
  createdAt, updatedAt
) VALUES (
  CURRENT_TIMESTAMP, CURRENT_TIMESTAMP
)
RETURNING id
`

func (q *Queries) CreateUserAndReturnId(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, createUserAndReturnId)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const findUserByCallsign = `-- name: FindUserByCallsign :one
SELECT users.id, users.name, users.createdat, users.updatedat, users.deletedat
FROM users
JOIN users_callsigns ON users.id = users_callsigns.user_id
JOIN callsigns ON users_callsigns.callsign_id = callsigns.id
WHERE callsigns.callsign = ?1
`

func (q *Queries) FindUserByCallsign(ctx context.Context, callsign string) (User, error) {
	row := q.db.QueryRowContext(ctx, findUserByCallsign, callsign)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Createdat,
		&i.Updatedat,
		&i.Deletedat,
	)
	return i, err
}

const findUserByEmail = `-- name: FindUserByEmail :one
SELECT users.id, users.name, users.createdat, users.updatedat, users.deletedat
FROM users
JOIN emails ON emails.user_id = users.id
WHERE emails.address = ?1
`

func (q *Queries) FindUserByEmail(ctx context.Context, address string) (User, error) {
	row := q.db.QueryRowContext(ctx, findUserByEmail, address)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Createdat,
		&i.Updatedat,
		&i.Deletedat,
	)
	return i, err
}

const getCallsignsForUser = `-- name: GetCallsignsForUser :many
SELECT callsigns.id, callsigns.createdat, callsigns.updatedat, callsigns.callsign, callsigns.class, callsigns.expires, callsigns.status, callsigns.grid, callsigns.latitude, callsigns.longitude, callsigns.firstname, callsigns.middlename, callsigns.lastname, callsigns.suffix, callsigns.address, callsigns.city, callsigns.state, callsigns.zip, callsigns.country
FROM callsigns
JOIN users_callsigns ON callsigns.id = users_callsigns.callsign_id
WHERE users_callsigns.user_id = ?1
`

func (q *Queries) GetCallsignsForUser(ctx context.Context, userID int64) ([]Callsign, error) {
	rows, err := q.db.QueryContext(ctx, getCallsignsForUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Callsign
	for rows.Next() {
		var i Callsign
		if err := rows.Scan(
			&i.ID,
			&i.Createdat,
			&i.Updatedat,
			&i.Callsign,
			&i.Class,
			&i.Expires,
			&i.Status,
			&i.Grid,
			&i.Latitude,
			&i.Longitude,
			&i.Firstname,
			&i.Middlename,
			&i.Lastname,
			&i.Suffix,
			&i.Address,
			&i.City,
			&i.State,
			&i.Zip,
			&i.Country,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEmailsForUser = `-- name: GetEmailsForUser :many
SELECT emails.id, emails.createdat, emails.updatedat, emails.user_id, emails.address, emails.isprimary, emails.ispublic, emails.isnotifiable, emails.verifiedat
FROM emails
WHERE emails.user_id = ?1
`

func (q *Queries) GetEmailsForUser(ctx context.Context, userID int64) ([]Email, error) {
	rows, err := q.db.QueryContext(ctx, getEmailsForUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Email
	for rows.Next() {
		var i Email
		if err := rows.Scan(
			&i.ID,
			&i.Createdat,
			&i.Updatedat,
			&i.UserID,
			&i.Address,
			&i.Isprimary,
			&i.Ispublic,
			&i.Isnotifiable,
			&i.Verifiedat,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUser = `-- name: GetUser :one
SELECT users.id, users.name, users.createdat, users.updatedat, users.deletedat
FROM users
WHERE id = ?1
LIMIT 1
`

func (q *Queries) GetUser(ctx context.Context, id int64) (User, error) {
	row := q.db.QueryRowContext(ctx, getUser, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Createdat,
		&i.Updatedat,
		&i.Deletedat,
	)
	return i, err
}

const setEmailAsPrimary = `-- name: SetEmailAsPrimary :exec
UPDATE emails
SET isPrimary = true
WHERE id = ?1
`

func (q *Queries) SetEmailAsPrimary(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, setEmailAsPrimary, id)
	return err
}

const setEmailAsSecondary = `-- name: SetEmailAsSecondary :exec
UPDATE emails
SET isPrimary = false
WHERE id = ?1
`

func (q *Queries) SetEmailAsSecondary(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, setEmailAsSecondary, id)
	return err
}

const users = `-- name: Users :many
SELECT id, name, createdat, updatedat, deletedat FROM users
`

func (q *Queries) Users(ctx context.Context) ([]User, error) {
	rows, err := q.db.QueryContext(ctx, users)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Createdat,
			&i.Updatedat,
			&i.Deletedat,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
