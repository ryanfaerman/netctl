// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: organizations.sql

package dao

import (
	"context"
	"database/sql"
	"time"
)

const createMembership = `-- name: CreateMembership :exec
INSERT INTO memberships (
  account_id, member_of, role_id, created_at
) VALUES (?1, ?2, ?3, CURRENT_TIMESTAMP)
`

type CreateMembershipParams struct {
	AccountID int64
	MemberOf  int64
	RoleID    int64
}

func (q *Queries) CreateMembership(ctx context.Context, arg CreateMembershipParams) error {
	_, err := q.db.ExecContext(ctx, createMembership, arg.AccountID, arg.MemberOf, arg.RoleID)
	return err
}

const createRoleOnAccount = `-- name: CreateRoleOnAccount :one
INSERT INTO roles (
  name, account_id, permissions, ranking
) VALUES (?1, ?2, ?3, ?4)
RETURNING id
`

type CreateRoleOnAccountParams struct {
	Name        string
	AccountID   int64
	Permissions int64
	Ranking     int64
}

func (q *Queries) CreateRoleOnAccount(ctx context.Context, arg CreateRoleOnAccountParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, createRoleOnAccount,
		arg.Name,
		arg.AccountID,
		arg.Permissions,
		arg.Ranking,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const findMembershipForAccountMember = `-- name: FindMembershipForAccountMember :one
SELECT 
  memberships.id, memberships.account_id, memberships.member_of, memberships.role_id, memberships.created_at,
  roles.name as role_name,
  roles.permissions as permissions
FROM memberships 
Join roles on memberships.role_id = roles.id
WHERE memberships.account_id = ?1 AND member_of = ?2
`

type FindMembershipForAccountMemberParams struct {
	AccountID int64
	MemberOf  int64
}

type FindMembershipForAccountMemberRow struct {
	ID          int64
	AccountID   int64
	MemberOf    int64
	RoleID      int64
	CreatedAt   time.Time
	RoleName    string
	Permissions int64
}

func (q *Queries) FindMembershipForAccountMember(ctx context.Context, arg FindMembershipForAccountMemberParams) (FindMembershipForAccountMemberRow, error) {
	row := q.db.QueryRowContext(ctx, findMembershipForAccountMember, arg.AccountID, arg.MemberOf)
	var i FindMembershipForAccountMemberRow
	err := row.Scan(
		&i.ID,
		&i.AccountID,
		&i.MemberOf,
		&i.RoleID,
		&i.CreatedAt,
		&i.RoleName,
		&i.Permissions,
	)
	return i, err
}

const getAccountKindMemberships = `-- name: GetAccountKindMemberships :many
SELECT 
  a.id, a.name, a.createdat, a.updatedat, a.deletedat, a.kind, a.about, a.settings, a.slug,
  r.id as role_id,
  r.permissions as role_permissions,
  r.ranking as role_ranking,
  r.name as role_name,
  m.created_at as membership_created_at
FROM accounts as a
JOIN memberships AS m ON a.id = m.member_of
JOIN roles AS r on m.role_id = r.id
WHERE m.account_id = ?1 AND a.kind = ?2
`

type GetAccountKindMembershipsParams struct {
	AccountID int64
	Kind      int64
}

type GetAccountKindMembershipsRow struct {
	ID                  int64
	Name                string
	Createdat           time.Time
	Updatedat           time.Time
	Deletedat           sql.NullTime
	Kind                int64
	About               string
	Settings            string
	Slug                string
	RoleID              int64
	RolePermissions     int64
	RoleRanking         int64
	RoleName            string
	MembershipCreatedAt time.Time
}

func (q *Queries) GetAccountKindMemberships(ctx context.Context, arg GetAccountKindMembershipsParams) ([]GetAccountKindMembershipsRow, error) {
	rows, err := q.db.QueryContext(ctx, getAccountKindMemberships, arg.AccountID, arg.Kind)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAccountKindMembershipsRow
	for rows.Next() {
		var i GetAccountKindMembershipsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Createdat,
			&i.Updatedat,
			&i.Deletedat,
			&i.Kind,
			&i.About,
			&i.Settings,
			&i.Slug,
			&i.RoleID,
			&i.RolePermissions,
			&i.RoleRanking,
			&i.RoleName,
			&i.MembershipCreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const hasPermissionOnAccount = `-- name: HasPermissionOnAccount :one
select memberships.id, memberships.account_id, memberships.member_of, memberships.role_id, memberships.created_at 
from memberships 
join roles on memberships.role_id = roles.id  
where 
  memberships.account_id=?1
  and member_of=?2
  and (roles.permissions & ?3) > 0
`

type HasPermissionOnAccountParams struct {
	AccountID  int64
	MemberOf   int64
	Permission int64
}

func (q *Queries) HasPermissionOnAccount(ctx context.Context, arg HasPermissionOnAccountParams) (Membership, error) {
	row := q.db.QueryRowContext(ctx, hasPermissionOnAccount, arg.AccountID, arg.MemberOf, arg.Permission)
	var i Membership
	err := row.Scan(
		&i.ID,
		&i.AccountID,
		&i.MemberOf,
		&i.RoleID,
		&i.CreatedAt,
	)
	return i, err
}
